module SetTest

include "set"
from Set use { Immutable as ImmSet }
include "list"
include "array"

// Data types used in multiple tests
enum Resource {
  Grain,
  Sheep,
  Brick,
  Wood,
}
record ResourceData {
  name: String,
  emoji: String,
}

// Mutable set tests

// Set.isEmpty

let e = Set.make()

assert Set.isEmpty(e)
Set.add("🌾", e)
assert !Set.isEmpty(e)

// Set.size

let s = Set.fromList(["🌾", "🐑", "🧱"])

assert Set.size(s) == 3

// Set.clear

let c = Set.fromList(["🌾", "🐑", "🧱"])

assert !Set.isEmpty(c)
assert Set.clear(c) == void
assert Set.isEmpty(c)

// Set.contains

let h = Set.fromList(["🌾", "🐑", "🧱"])

assert Set.contains("🌾", h)
assert Set.contains("🐑", h)
assert Set.contains("🧱", h)
assert !Set.contains("🌳", h)

// Set.add

let vars = Set.make()

assert Set.add(Grain, vars) == void
assert Set.add(Sheep, vars) == void
assert Set.add(Grain, vars) == void

assert Set.size(vars) == 2

let recs = Set.make()

assert Set.add({ name: "Grain", emoji: "🌾" }, recs) == void
assert Set.add({ name: "Sheep", emoji: "🐑" }, recs) == void
assert Set.add({ name: "Brick", emoji: "🧱" }, recs) == void
assert Set.add({ name: "Grain", emoji: "🌾" }, recs) == void
assert Set.add({ name: "Sheep", emoji: "🐑" }, recs) == void
assert Set.add({ name: "Brick", emoji: "🧱" }, recs) == void

assert Set.size(recs) == 3

// Set.remove

let r = Set.fromList(["🌾", "🐑", "🧱"])

assert Set.size(r) == 3

assert Set.remove("🌾", r) == void

assert Set.size(r) == 2
assert !Set.contains("🌾", r)

assert Set.remove("🐑", r) == void
assert Set.remove("🧱", r) == void

assert Set.isEmpty(r)

// Set.filter

let makeTestSet = () => Set.fromList([Grain, Sheep, Brick])

let emptySet = Set.make()

let filterTestSet = makeTestSet()

Set.filter(key => fail "Shouldn't be called", emptySet)
Set.filter(key => key == Sheep, filterTestSet)

assert !Set.contains(Grain, filterTestSet)
assert Set.contains(Sheep, filterTestSet)
assert !Set.contains(Brick, filterTestSet)

// Set.reject

let rejectTestSet = makeTestSet()

Set.reject(key => fail "Shouldn't be called", emptySet)
Set.reject(key => key == Sheep, rejectTestSet)

assert Set.contains(Grain, rejectTestSet)
assert !Set.contains(Sheep, rejectTestSet)
assert Set.contains(Brick, rejectTestSet)

// Set.reduce

let reduceTestSet = makeTestSet()

let result = Set.reduce((acc, key) => fail "Shouldn't be called", 0, emptySet)

assert result == 0

let mut called = 0

let result = Set.reduce((acc, key) => {
  called += 1
  match (key) {
    Grain => void,
    Sheep => void,
    Brick => void,
    _ => fail "Set.reduce() should not contain this value.",
  }
  [key, ...acc]
}, [], reduceTestSet)

assert called == 3
assert List.contains(Grain, result)
assert List.contains(Sheep, result)
assert List.contains(Brick, result)

// Set.forEach

let forEachTestSet = makeTestSet()

Set.forEach(key => fail "Shouldn't be called", emptySet)

let mut called = 0

Set.forEach(key => {
  called += 1
  match (key) {
    Grain => void,
    Sheep => void,
    Brick => void,
    _ => fail "Set.forEach() should not contain this value.",
  }
}, forEachTestSet)

assert called == 3

// Set.diff

let d = Set.fromList([0, 1, 2, 3])
let e = Set.fromList([1, 2, 3, 4])

let diffSet = Set.diff(d, e)

assert Set.size(diffSet) == 2
assert Set.contains(0, diffSet)
assert !Set.contains(1, diffSet)
assert !Set.contains(2, diffSet)
assert !Set.contains(3, diffSet)
assert Set.contains(4, diffSet)

// Set.union

let unionSet = Set.union(d, e)

assert Set.size(unionSet) == 5
assert Set.contains(0, unionSet)
assert Set.contains(1, unionSet)
assert Set.contains(2, unionSet)
assert Set.contains(3, unionSet)
assert Set.contains(4, unionSet)

// Set.intersect

let intersectSet = Set.intersect(d, e)

assert Set.size(intersectSet) == 3
assert !Set.contains(0, intersectSet)
assert Set.contains(1, intersectSet)
assert Set.contains(2, intersectSet)
assert Set.contains(3, intersectSet)
assert !Set.contains(4, intersectSet)

// Set.fromList

let k = Set.fromList([1, 1, 1])

assert Set.size(k) == 1
assert Set.contains(1, k)

// Set.toList

let o = Set.fromList([0, 1, 2, 3, 4])

let l = Set.toList(o)

assert List.length(l) == 5
assert List.contains(0, l)
assert List.contains(1, l)
assert List.contains(2, l)
assert List.contains(3, l)
assert List.contains(4, l)

// Set.fromArray

let q = Set.fromArray([> 0, 0, 0])

assert Set.size(q) == 1
assert Set.contains(0, q)

// Set.toArray

let p = Set.fromArray([> 0, 1, 2, 3, 4, 3, 2, 1, 0])

let r = Set.toArray(p)

assert Array.length(r) == 5
assert Array.contains(0, r)
assert Array.contains(1, r)
assert Array.contains(2, r)
assert Array.contains(3, r)
assert Array.contains(4, r)

// Resizes the map when it grows
// TODO(#190): Don't use these internals, as they need to change after 190 is fixed

let resize = Set.makeSized(1)

// (nodeCount, bucketLength)
assert Set.getInternalStats(resize) == (0, 1)

Set.add("🌾", resize)
Set.add("🐑", resize)

// (nodeCount, bucketLength)
assert Set.getInternalStats(resize) == (2, 1)

Set.add("🧱", resize)

// (nodeCount, bucketLength)
assert Set.getInternalStats(resize) == (3, 2)

// Regression tests for https://github.com/grain-lang/grain/issues/497

let largeSet = Set.fromArray(Array.init(128, i => i))

// (nodeCount, bucketLength)
assert Set.getInternalStats(largeSet) == (128, 64)

// Immutable set tests

// ImmSet.isEmpty

let mut e = ImmSet.empty

assert ImmSet.isEmpty(e)
e = ImmSet.remove("🌾", e)
assert ImmSet.isEmpty(e)
let newE = ImmSet.add("🌾", e)
assert !ImmSet.isEmpty(newE)
assert ImmSet.isEmpty(e)

// ImmSet.size

let s = ImmSet.fromList(["🌾", "🐑", "🧱"])

assert ImmSet.size(s) == 3

// ImmSet.contains

let h = ImmSet.fromList(["🌾", "🐑", "🧱"])

assert ImmSet.contains("🌾", h)
assert ImmSet.contains("🐑", h)
assert ImmSet.contains("🧱", h)
assert !ImmSet.contains("🌳", h)

// ImmSet.add

let mut vars = ImmSet.empty

vars = ImmSet.add(Grain, vars)
vars = ImmSet.add(Sheep, vars)
vars = ImmSet.add(Grain, vars)

assert ImmSet.size(vars) == 2

let mut recs = ImmSet.empty

recs = ImmSet.add({ name: "Grain", emoji: "🌾" }, recs)
recs = ImmSet.add({ name: "Sheep", emoji: "🐑" }, recs)
recs = ImmSet.add({ name: "Brick", emoji: "🧱" }, recs)
recs = ImmSet.add({ name: "Grain", emoji: "🌾" }, recs)
recs = ImmSet.add({ name: "Sheep", emoji: "🐑" }, recs)
recs = ImmSet.add({ name: "Brick", emoji: "🧱" }, recs)

assert ImmSet.size(recs) == 3

// ImmSet.remove

let mut r = ImmSet.fromList(["🌾", "🐑", "🧱"])

assert ImmSet.size(r) == 3

r = ImmSet.remove("🌾", r)

assert ImmSet.size(r) == 2
assert !ImmSet.contains("🌾", r)

r = ImmSet.remove("🐑", r)
r = ImmSet.remove("🧱", r)

assert ImmSet.isEmpty(r)

// ImmSet.filter

let makeTestSet = () => ImmSet.fromList([Grain, Sheep, Brick])

let mut filterTestSet = makeTestSet()

ImmSet.filter(key => fail "Shouldn't be called", ImmSet.empty)
filterTestSet = ImmSet.filter(key => key == Sheep, filterTestSet)

assert !ImmSet.contains(Grain, filterTestSet)
assert ImmSet.contains(Sheep, filterTestSet)
assert !ImmSet.contains(Brick, filterTestSet)

// ImmSet.reject

let mut rejectTestSet = makeTestSet()

ImmSet.reject(key => fail "Shouldn't be called", ImmSet.empty)
rejectTestSet = ImmSet.reject(key => key == Sheep, rejectTestSet)

assert ImmSet.contains(Grain, rejectTestSet)
assert !ImmSet.contains(Sheep, rejectTestSet)
assert ImmSet.contains(Brick, rejectTestSet)

// ImmSet.reduce

let reduceTestSet = ImmSet.fromList([1, 3, 2, 5, 4])

let result = ImmSet.reduce((acc, key) => fail "Shouldn't be called",
0,
ImmSet.empty
)

assert result == 0

let mut called = 0

let result = ImmSet.reduce((acc, key) => {
  called += 1
  [key, ...acc]
}, [], reduceTestSet)

assert called == 5
assert result == [5, 4, 3, 2, 1]

// ImmSet.forEach

let forEachTestSet = makeTestSet()

ImmSet.forEach(key => fail "Shouldn't be called", ImmSet.empty)

let mut called = 0

ImmSet.forEach(key => {
  called += 1
  match (key) {
    Grain => void,
    Sheep => void,
    Brick => void,
    _ => fail "ImmSet.forEach() should not contain this value.",
  }
}, forEachTestSet)

assert called == 3

// ImmSet.diff

let d = ImmSet.fromList([0, 1, 2, 3, 4, 5, 6])
let e = ImmSet.fromList([4, 2, 1, 3, 0, -2, -1, -3])

let diffSet = ImmSet.diff(d, e)

assert ImmSet.size(diffSet) == 5
assert [-3, -2, -1, 5, 6] == ImmSet.toList(diffSet)

// ImmSet.union

let unionSet = ImmSet.union(d, e)

assert ImmSet.size(unionSet) == 10
assert [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6] == ImmSet.toList(unionSet)

// ImmSet.intersect

let intersectSet = ImmSet.intersect(d, e)

assert ImmSet.size(intersectSet) == 5
assert [0, 1, 2, 3, 4] == ImmSet.toList(intersectSet)

// ImmSet.fromList

let k = ImmSet.fromList([1, 1, 1])

assert ImmSet.size(k) == 1
assert ImmSet.contains(1, k)

// ImmSet.toList

let o = ImmSet.fromList([0, 2, 1, 3, 0, 4, 2])

let l = ImmSet.toList(o)

assert l == [0, 1, 2, 3, 4]

// ImmSet.fromArray

let q = ImmSet.fromArray([> 0, 0, 0])

assert ImmSet.size(q) == 1
assert ImmSet.contains(0, q)

// ImmSet.toArray

let p = ImmSet.fromArray([> 0, 1, 2, 3, 4, 3, 2, 1, 0])

let r = ImmSet.toArray(p)

assert r == [> 0, 1, 2, 3, 4]
