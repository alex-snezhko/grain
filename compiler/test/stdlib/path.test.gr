import Path from "path"
import Result from "result"
import Option from "option"
import List from "list"

// test that a variety of properties hold for valid relative/absolute paths
record RelTestData {
  pathStr: String,
  expParent: String,
  expStr: String,
  expName: Option<String>,
  expStem: Option<String>,
  expExt: Option<String>,
}

let relTests = [
  {
    pathStr: "./dir/file.txt",
    expParent: "./dir",
    expStr: "./dir/file.txt",
    expName: Some("file.txt"),
    expStem: Some("file"),
    expExt: Some(".txt"),
  },
  {
    pathStr: "file",
    expParent: ".",
    expStr: "./file",
    expName: Some("file"),
    expStem: Some("file"),
    expExt: None,
  },
  {
    pathStr: "dir/../../",
    expParent: "../..",
    expStr: "..",
    expName: None,
    expStem: None,
    expExt: None,
  },
  {
    pathStr: ".git",
    expParent: ".",
    expStr: "./.git",
    expName: Some(".git"),
    expStem: Some(".git"),
    expExt: None,
  },
  {
    pathStr: "a.tar.gz",
    expParent: ".",
    expStr: "./a.tar.gz",
    expName: Some("a.tar.gz"),
    expStem: Some("a.tar"),
    expExt: Some(".gz"),
  },
  {
    pathStr: ".",
    expParent: "..",
    expStr: ".",
    expName: None,
    expStem: None,
    expExt: None,
  },
  {
    pathStr: "..",
    expParent: "../..",
    expStr: "..",
    expName: None,
    expStem: None,
    expExt: None,
  },
  {
    pathStr: "../../file",
    expParent: "../..",
    expStr: "../../file",
    expName: Some("file"),
    expStem: Some("file"),
    expExt: None,
  },
  {
    pathStr: "./",
    expParent: "..",
    expStr: ".",
    expName: None,
    expStem: None,
    expExt: None,
  },
  {
    pathStr: "dir//file.txt///",
    expParent: "dir",
    expStr: "./dir/file.txt",
    expName: Some("file.txt"),
    expStem: Some("file"),
    expExt: Some(".txt"),
  },
  {
    pathStr: ".\\dir\\file.txt",
    expParent: ".",
    expStr: "./.\\dir\\file.txt",
    expName: Some(".\\dir\\file.txt"),
    expStem: Some(".\\dir\\file"),
    expExt: Some(".txt"),
  },
]

List.forEach(({ pathStr, expParent, expStr, expName, expStem, expExt }) => {
  let path = Option.unwrap(Path.relative(pathStr))
  assert Path.toString(path, Path.Posix) == expStr
  assert Option.unwrap(Path.relative(expParent)) == Path.parent(path)
  assert expName == Path.name(path)
  assert expStem == Path.stem(path)
  assert expExt == Path.extension(path)
}, relTests)

record AbsTestData {
  pathStr: String,
  expParent: String,
  expStr: String,
  expRoot: Path.AbsoluteRoot,
  expName: Option<String>,
  expStem: Option<String>,
  expExt: Option<String>,
}

let absTests = [
  {
    pathStr: "/usr/bin",
    expParent: "/usr",
    expStr: "/usr/bin",
    expRoot: Path.Root,
    expName: Some("bin"),
    expStem: Some("bin"),
    expExt: None,
  },
  {
    pathStr: "/bin",
    expParent: "/",
    expStr: "/bin",
    expRoot: Path.Root,
    expName: Some("bin"),
    expStem: Some("bin"),
    expExt: None,
  },
  {
    pathStr: "/bin/dir/..",
    expParent: "/",
    expStr: "/bin",
    expRoot: Path.Root,
    expName: Some("bin"),
    expStem: Some("bin"),
    expExt: None,
  },
  {
    pathStr: "/../..",
    expParent: "/",
    expStr: "/",
    expRoot: Path.Root,
    expName: None,
    expStem: None,
    expExt: None,
  },
  {
    pathStr: "/",
    expParent: "/",
    expStr: "/",
    expRoot: Path.Root,
    expName: None,
    expStem: None,
    expExt: None,
  },
  {
    pathStr: "C:/",
    expParent: "C:/",
    expStr: "C:/",
    expRoot: Path.Drive('C'),
    expName: None,
    expStem: None,
    expExt: None,
  },
  {
    pathStr: "C:/.././..",
    expParent: "C:/",
    expStr: "C:/",
    expRoot: Path.Drive('C'),
    expName: None,
    expStem: None,
    expExt: None,
  },
  {
    pathStr: "C:/Users/me.txt",
    expParent: "C:/Users",
    expStr: "C:/Users/me.txt",
    expRoot: Path.Drive('C'),
    expName: Some("me.txt"),
    expStem: Some("me"),
    expExt: Some(".txt"),
  },
]

List.forEach(({
  pathStr,
  expParent,
  expStr,
  expRoot,
  expName,
  expStem,
  expExt,
}) => {
  let path = Option.unwrap(Path.absolute(pathStr))
  assert Path.toString(path, Path.Posix) == expStr
  assert Option.unwrap(Path.absolute(expParent)) == Path.parent(path)
  assert expRoot == Path.root(path)
  assert expName == Path.name(path)
  assert expStem == Path.stem(path)
  assert expExt == Path.extension(path)
}, absTests)

// test invalidly trying to construct paths
assert Path.relative("/usr/bin") == None
assert Path.relative("C:/Users/me") == None
assert Path.absolute("./file.txt") == None
assert Path.absolute("file.txt") == None
assert Path.absolute("../..") == None

record AppendTestData {
  base: String,
  toAppend: String,
  final: String,
}

// test appending onto relative and absolute paths
let appendRelTests = [
  { base: "dir", toAppend: "inner", final: "dir/inner" },
  {
    base: "./dir/inner",
    toAppend: "./innerer/file.txt",
    final: "dir/inner/innerer/file.txt",
  },
  { base: ".", toAppend: ".././../", final: "../.." },
]

List.forEach(({ base, toAppend, final }) => {
  let path = Option.unwrap(Path.relative(base))
  let finalPath = Option.unwrap(Path.relative(final))
  let appendStr = Option.unwrap(Path.appendString(path, toAppend))
  let appendPath = Path.append(path, Option.unwrap(Path.relative(toAppend)))
  assert appendStr == finalPath
  assert appendPath == finalPath
}, appendRelTests)

let appendAbsTests = [
  { base: "/usr", toAppend: "./bin", final: "/usr/bin" },
  { base: "/usr", toAppend: "../bin", final: "/bin" },
  { base: "/", toAppend: "../..", final: "/" },
  { base: "C:/", toAppend: "../..", final: "C:/" },
]

List.forEach(({ base, toAppend, final }) => {
  let path = Option.unwrap(Path.absolute(base))
  let finalPath = Option.unwrap(Path.absolute(final))
  let appendStr = Option.unwrap(Path.appendString(path, toAppend))
  let appendPath = Path.append(path, Option.unwrap(Path.relative(toAppend)))
  assert appendStr == finalPath
  assert appendPath == finalPath
}, appendAbsTests)

record RelativeToTestData {
  source: String,
  dest: String,
  result: Result<Path.Path<Path.Relative>, Path.RelativizationError>,
}
// test the relativeTo function
let valid = path => Ok(Option.unwrap(Path.relative(path)))
let relativeToRelTests = [
  { source: "./dir", dest: "./dir/inner", result: valid("./inner") },
  { source: "./dir", dest: ".", result: valid("..") },
  { source: ".", dest: ".", result: valid(".") },
  { source: "..", dest: "../../other", result: valid("../other") },
  { source: "..", dest: ".", result: Err(Path.ImpossibleRelativization) },
]

List.forEach(({ source, dest, result }) => {
  let source = Option.unwrap(Path.relative(source))
  let dest = Option.unwrap(Path.relative(dest))
  assert Path.relativeTo(source, dest) == result
}, relativeToRelTests)

let relativeToAbsTests = [
  { source: "/usr", dest: "/usr/bin", result: valid("./bin") },
  { source: "/", dest: "/", result: valid(".") },
  { source: "/usr/bin", dest: "/usr/bin", result: valid(".") },
  { source: "/usr/bin", dest: "/", result: valid("../..") },
  { source: "/usr/bin", dest: "/home/me", result: valid("../../home/me") },
  { source: "/bin", dest: "C:/Users", result: Err(Path.DifferentRoots) },
]

List.forEach(({ source, dest, result }) => {
  let source = Option.unwrap(Path.absolute(source))
  let dest = Option.unwrap(Path.absolute(dest))
  assert Path.relativeTo(source, dest) == result
}, relativeToAbsTests)

// miscellaneous tests
assert Path.toString(
  Option.unwrap(Path.absolute("C:/Users/me")),
  Path.Windows
) ==
"C:\\Users\\me"
