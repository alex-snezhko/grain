module MapTest

include "map"
from Map use { Immutable as ImmMap }
include "list"
include "array"

// Data types used in multiple tests
enum Resource {
  Grain,
  Sheep,
  Brick,
  Wood,
}
record ResourceData {
  name: String,
  emoji: String,
}

// Mutable map tests

// Map.isEmpty()

let e = Map.make()

assert Map.isEmpty(e)
Map.set("🌾", "🌾", e)
assert !Map.isEmpty(e)

// Map.size()

let s = Map.make()

Map.set("🌾", 1, s)
Map.set("🐑", 2, s)
Map.set("🧱", 3, s)

assert Map.size(s) == 3

// Map.clear()

let c = Map.make()

Map.set("🌾", 1, c)
Map.set("🐑", 2, c)
Map.set("🧱", 3, c)

assert !Map.isEmpty(c)

assert Map.clear(c) == void

assert Map.isEmpty(c)

// Map.contains()

let h = Map.make()

Map.set("🌾", 1, h)
Map.set("🐑", 2, h)
Map.set("🧱", 3, h)

assert Map.contains("🌾", h)
assert Map.contains("🐑", h)
assert Map.contains("🧱", h)
assert !Map.contains("🌳", h)

// Map.set() & Map.get()

// With Number keys
let nums = Map.make()

assert Map.set(1, "🌾", nums) == void
assert Map.set(2, "🐑", nums) == void
assert Map.set(3, "🧱", nums) == void

assert Map.get(1, nums) == Some("🌾")
assert Map.get(2, nums) == Some("🐑")
assert Map.get(3, nums) == Some("🧱")
assert Map.get(4, nums) == None

// With String keys
let strs = Map.make()

assert Map.set("🌾", 1, strs) == void
assert Map.set("🐑", 2, strs) == void
assert Map.set("🧱", 3, strs) == void

assert Map.get("🌾", strs) == Some(1)
assert Map.get("🐑", strs) == Some(2)
assert Map.get("🧱", strs) == Some(3)
assert Map.get("🌳", strs) == None

// With variant keys
let vars = Map.make()

assert Map.set(Grain, "🌾", vars) == void
assert Map.set(Sheep, "🐑", vars) == void
assert Map.set(Brick, "🧱", vars) == void

assert Map.get(Grain, vars) == Some("🌾")
assert Map.get(Sheep, vars) == Some("🐑")
assert Map.get(Brick, vars) == Some("🧱")
assert Map.get(Wood, vars) == None

// With record keys
let recs = Map.make()

assert Map.set({ name: "Grain", emoji: "🌾" }, 1, recs) == void
assert Map.set({ name: "Sheep", emoji: "🐑" }, 2, recs) == void
assert Map.set({ name: "Brick", emoji: "🧱" }, 3, recs) == void

assert Map.get({ name: "Grain", emoji: "🌾" }, recs) == Some(1)
assert Map.get({ name: "Sheep", emoji: "🐑" }, recs) == Some(2)
assert Map.get({ name: "Brick", emoji: "🧱" }, recs) == Some(3)
assert Map.get({ name: "Wood", emoji: "🌳" }, recs) == None

// Overwriting data
let o = Map.make()

assert Map.set(1, "🐑", o) == void
assert Map.set(1, "🌾", o) == void

assert Map.get(1, o) == Some("🌾")

// Map.remove()

let r = Map.make()

Map.set("🌾", 1, r)
Map.set("🐑", 2, r)
Map.set("🧱", 3, r)

assert Map.size(r) == 3

assert Map.remove("🐑", r) == void

assert Map.size(r) == 2
assert Map.get("🐑", r) == None

assert Map.remove("🌳", r) == void

assert Map.size(r) == 2

assert Map.remove("🌾", r) == void
assert Map.get("🌾", r) == None

assert Map.remove("🧱", r) == void
assert Map.get("🧱", r) == None

assert Map.isEmpty(r)

// Map.forEach()

let fe = Map.make()

Map.set(Grain, "🌾", fe)
Map.set(Sheep, "🐑", fe)
Map.set(Brick, "🧱", fe)

let mut called = 0

Map.forEach((key, value) => {
  called += 1
  match (key) {
    Grain => assert value == "🌾",
    Sheep => assert value == "🐑",
    Brick => assert value == "🧱",
    _ => fail "Map.forEach() should not contain this value.",
  }
}, fe)

assert called == 3

// Map.reduce()

let r = Map.make()

Map.set(Grain, 1, r)
Map.set(Sheep, 2, r)
Map.set(Brick, 3, r)

let mut called = 0

let result = Map.reduce((acc, key, value) => {
  called += 1
  match (key) {
    Grain => assert value == 1,
    Sheep => assert value == 2,
    Brick => assert value == 3,
    _ => fail "Map.reduce() should not contain this value.",
  }
  acc + value
}, 0, r)

assert called == 3
assert result == 6

// Map.keys() & Map.values();

let kvs = Map.make()

Map.set(Grain, "🌾", kvs)
Map.set(Sheep, "🐑", kvs)
Map.set(Brick, "🧱", kvs)

let keys = Map.keys(kvs)

// No order is guaranteed
assert List.contains(Grain, keys)
assert List.contains(Sheep, keys)
assert List.contains(Brick, keys)
assert !List.contains(Wood, keys)

let vals = Map.values(kvs)

// No order is guaranteed
assert List.contains("🌾", vals)
assert List.contains("🐑", vals)
assert List.contains("🧱", vals)
assert !List.contains("🌳", vals)

// Map.toList()

let tl = Map.make()

Map.set(Grain, "🌾", tl)
Map.set(Sheep, "🐑", tl)
Map.set(Brick, "🧱", tl)

let lis = Map.toList(tl)

// No order is guaranteed
assert List.contains((Grain, "🌾"), lis)
assert List.contains((Sheep, "🐑"), lis)
assert List.contains((Brick, "🧱"), lis)
assert !List.contains((Wood, "🌳"), lis)

// Map.fromList()

let fl = Map.fromList([(Grain, "🌾"), (Sheep, "🐑"), (Brick, "🧱")])

assert Map.contains(Grain, fl)
assert Map.contains(Sheep, fl)
assert Map.contains(Brick, fl)
assert !Map.contains(Wood, fl)

// Map.toArray()

let ta = Map.make()

Map.set(Grain, "🌾", ta)
Map.set(Sheep, "🐑", ta)
Map.set(Brick, "🧱", ta)

let arr = Map.toArray(ta)

// No order is guaranteed
assert Array.contains((Grain, "🌾"), arr)
assert Array.contains((Sheep, "🐑"), arr)
assert Array.contains((Brick, "🧱"), arr)
assert !Array.contains((Wood, "🌳"), arr)

// Map.fromArray()

let fa = Map.fromArray([> (Grain, "🌾"), (Sheep, "🐑"), (Brick, "🧱")])

assert Map.contains(Grain, fa)
assert Map.contains(Sheep, fa)
assert Map.contains(Brick, fa)
assert !Map.contains(Wood, fa)

// Resizes the map when it grows
// TODO(#190): Don't use these internals, as they need to change after 190 is fixed

let resize = Map.makeSized(1)

// (nodeCount, bucketLength)
assert Map.getInternalStats(resize) == (0, 1)

Map.set("🌾", 1, resize)
Map.set("🐑", 1, resize)

// (nodeCount, bucketLength)
assert Map.getInternalStats(resize) == (2, 1)

Map.set("🧱", 1, resize)

// (nodeCount, bucketLength)
assert Map.getInternalStats(resize) == (3, 2)

// Regression tests for https://github.com/grain-lang/grain/issues/497

let largeMap = Map.fromArray(Array.init(128, i => (i, i)))

// (nodeCount, bucketLength)
assert Map.getInternalStats(largeMap) == (128, 64)

// Map.filter()

let makeFilterTestMap = () =>
  Map.fromList([(Grain, "g"), (Sheep, "s"), (Brick, "b")])

let filterTestMap = makeFilterTestMap()

Map.filter((key, value) => key == Sheep, filterTestMap)

assert !Map.contains(Grain, filterTestMap)
assert Map.contains(Sheep, filterTestMap)
assert !Map.contains(Brick, filterTestMap)

let filterTestMap = makeFilterTestMap()

Map.filter((key, value) => value == "b" || value == "s", filterTestMap)

assert !Map.contains(Grain, filterTestMap)
assert Map.contains(Sheep, filterTestMap)
assert Map.contains(Brick, filterTestMap)

let filterTestMap = makeFilterTestMap()

Map.filter((key, value) => value == "invalid", filterTestMap)

assert Map.size(filterTestMap) == 0

let filterTestMap = makeFilterTestMap()

Map.filter((key, value) => true, filterTestMap)

assert Map.size(filterTestMap) == 3

// Regression tests for https://github.com/grain-lang/grain/issues/350

let makeFilterTestMap = () => {
  let map = Map.make()
  Map.set(Grain, "g", map)
  Map.set(Sheep, "s", map)
  Map.set(Brick, "b", map)
  map
}

let filterTestMap = makeFilterTestMap()

Map.filter((key, value) => key == Sheep, filterTestMap)

assert !Map.contains(Grain, filterTestMap)
assert Map.contains(Sheep, filterTestMap)
assert !Map.contains(Brick, filterTestMap)

// Map.reject()

let rejectTestMap = makeFilterTestMap()

Map.reject((key, value) => key == Sheep, rejectTestMap)

assert Map.contains(Grain, rejectTestMap)
assert !Map.contains(Sheep, rejectTestMap)
assert Map.contains(Brick, rejectTestMap)

let rejectTestMap = makeFilterTestMap()

Map.reject((key, value) => value == "b" || value == "s", rejectTestMap)

assert Map.contains(Grain, rejectTestMap)
assert !Map.contains(Sheep, rejectTestMap)
assert !Map.contains(Brick, rejectTestMap)

let rejectTestMap = makeFilterTestMap()

Map.reject((key, value) => true, rejectTestMap)

assert Map.size(rejectTestMap) == 0

let rejectTestMap = makeFilterTestMap()

Map.reject((key, value) => false, rejectTestMap)

assert Map.size(rejectTestMap) == 3

// Map.update()

let toUpdate = Map.fromList([("a", 1), ("b", 2), ("c", 3)])

Map.update(
  "b",
  old => {
    assert old == Some(2)
    Some(4)
  },
  toUpdate
)

assert Map.get("b", toUpdate) == Some(4)

Map.update(
  "d",
  old => {
    assert old == None
    Some(10)
  },
  toUpdate
)

assert Map.get("d", toUpdate) == Some(10)

Map.update(
  "c",
  old => {
    assert old == Some(3)
    None
  },
  toUpdate
)

assert Map.contains("c", toUpdate) == false

// Immutable map tests

let strKeys = ImmMap.fromList([("🌾", 1), ("🐑", 2), ("🧱", 3)])
let numKeys = ImmMap.fromList([(1, "🌾"), (2, "🐑"), (3, "🧱")])
let varKeys = ImmMap.fromList(
  [(Grain, "🌾"), (Sheep, "🐑"), (Brick, "🧱")]
)
let recordKeys = ImmMap.fromList(
  [
    ({ name: "Grain", emoji: "🌾" }, 1),
    ({ name: "Sheep", emoji: "🐑" }, 2),
    ({ name: "Brick", emoji: "🧱" }, 3),
  ]
)

// ImmMap.isEmpty()

let mut e = ImmMap.empty

assert ImmMap.isEmpty(e)
e = ImmMap.remove("🌾", e)
assert ImmMap.isEmpty(e)
let newE = ImmMap.set("🌾", "🌾", e)
assert !ImmMap.isEmpty(newE)
assert ImmMap.isEmpty(e)

// ImmMap.size()

let m = strKeys

assert ImmMap.size(m) == 3

// ImmMap.contains()

assert ImmMap.contains("🌾", m)
assert ImmMap.contains("🐑", m)
assert ImmMap.contains("🧱", m)
assert !ImmMap.contains("🌳", m)

// ImmMap.set() & ImmutableMap.get()

// With Number keys
let nums = numKeys

assert ImmMap.get(1, nums) == Some("🌾")
assert ImmMap.get(2, nums) == Some("🐑")
assert ImmMap.get(3, nums) == Some("🧱")
assert ImmMap.get(4, nums) == None

// With String keys
let mut strs = strKeys

assert ImmMap.get("🌾", strs) == Some(1)
assert ImmMap.get("🐑", strs) == Some(2)
assert ImmMap.get("🧱", strs) == Some(3)
assert ImmMap.get("🌳", strs) == None

// With variant keys
let vars = varKeys

assert ImmMap.get(Grain, vars) == Some("🌾")
assert ImmMap.get(Sheep, vars) == Some("🐑")
assert ImmMap.get(Brick, vars) == Some("🧱")
assert ImmMap.get(Wood, vars) == None

// With record keys
let recs = recordKeys

assert ImmMap.get({ name: "Grain", emoji: "🌾" }, recs) == Some(1)
assert ImmMap.get({ name: "Sheep", emoji: "🐑" }, recs) == Some(2)
assert ImmMap.get({ name: "Brick", emoji: "🧱" }, recs) == Some(3)
assert ImmMap.get({ name: "Wood", emoji: "🌳" }, recs) == None

// Overwriting data
let mut o = ImmMap.empty

o = ImmMap.set(1, "🐑", o)
o = ImmMap.set(1, "🌾", o)

assert ImmMap.get(1, o) == Some("🌾")

// ImmMap.remove()

let mut r = strKeys

assert ImmMap.size(r) == 3

r = ImmMap.remove("🐑", r)

assert ImmMap.size(r) == 2
assert ImmMap.get("🐑", r) == None

r = ImmMap.remove("🌳", r)

assert ImmMap.size(r) == 2

r = ImmMap.remove("🌾", r)
assert ImmMap.get("🌾", r) == None

r = ImmMap.remove("🧱", r)
assert ImmMap.get("🧱", r) == None

assert ImmMap.isEmpty(r)

// ImmMap.forEach()

let fe = varKeys

let mut called = 0

ImmMap.forEach((key, value) => {
  called += 1
  match (key) {
    Grain => assert value == "🌾",
    Sheep => assert value == "🐑",
    Brick => assert value == "🧱",
    _ => fail "ImmMap.forEach() should not contain this value.",
  }
}, fe)

assert called == 3

// ImmMap.reduce()

let mut r = ImmMap.empty

r = ImmMap.set(Grain, 1, r)
r = ImmMap.set(Sheep, 2, r)
r = ImmMap.set(Brick, 3, r)

let mut called = 0

let result = ImmMap.reduce((acc, key, value) => {
  called += 1
  match (key) {
    Grain => assert value == 1,
    Sheep => assert value == 2,
    Brick => assert value == 3,
    _ => fail "ImmMap.reduce() should not contain this value.",
  }
  acc + value
}, 0, r)

assert called == 3
assert result == 6

// ImmMap.keys() & ImmutableMap.values();

let kvs = varKeys

let keys = ImmMap.keys(kvs)

assert List.contains(Grain, keys)
assert List.contains(Sheep, keys)
assert List.contains(Brick, keys)
assert !List.contains(Wood, keys)

let vals = ImmMap.values(kvs)

assert List.contains("🌾", vals)
assert List.contains("🐑", vals)
assert List.contains("🧱", vals)
assert !List.contains("🌳", vals)

// ImmMap.toList()

let tl = varKeys

let lis = ImmMap.toList(tl)

// No order is guaranteed
assert List.contains((Grain, "🌾"), lis)
assert List.contains((Sheep, "🐑"), lis)
assert List.contains((Brick, "🧱"), lis)
assert !List.contains((Wood, "🌳"), lis)

// ImmMap.fromList()

let fl = ImmMap.fromList([(Grain, "🌾"), (Sheep, "🐑"), (Brick, "🧱")])

assert ImmMap.contains(Grain, fl)
assert ImmMap.contains(Sheep, fl)
assert ImmMap.contains(Brick, fl)
assert !ImmMap.contains(Wood, fl)

// ImmMap.toArray()

let ta = varKeys

let arr = ImmMap.toArray(ta)

// No order is guaranteed
assert Array.contains((Grain, "🌾"), arr)
assert Array.contains((Sheep, "🐑"), arr)
assert Array.contains((Brick, "🧱"), arr)
assert !Array.contains((Wood, "🌳"), arr)

// ImmMap.fromArray()

let fa = ImmMap.fromArray([> (Grain, "🌾"), (Sheep, "🐑"), (Brick, "🧱")])

assert ImmMap.contains(Grain, fa)
assert ImmMap.contains(Sheep, fa)
assert ImmMap.contains(Brick, fa)
assert !ImmMap.contains(Wood, fa)

// ImmMap.filter()

let makeFilterTestImmutableMap = () =>
  ImmMap.fromList([(Grain, "g"), (Sheep, "s"), (Brick, "b")])

let mut filterTestImmutableMap = makeFilterTestImmutableMap()

filterTestImmutableMap = ImmMap.filter((key, value) =>
  key == Sheep, filterTestImmutableMap)

assert !ImmMap.contains(Grain, filterTestImmutableMap)
assert ImmMap.contains(Sheep, filterTestImmutableMap)
assert !ImmMap.contains(Brick, filterTestImmutableMap)

let mut filterTestImmutableMap = makeFilterTestImmutableMap()

filterTestImmutableMap = ImmMap.filter((key, value) =>
  value == "b" || value == "s", filterTestImmutableMap)

assert !ImmMap.contains(Grain, filterTestImmutableMap)
assert ImmMap.contains(Sheep, filterTestImmutableMap)
assert ImmMap.contains(Brick, filterTestImmutableMap)

let mut filterTestImmutableMap = makeFilterTestImmutableMap()

filterTestImmutableMap = ImmMap.filter((key, value) =>
  value == "invalid", filterTestImmutableMap)

assert ImmMap.size(filterTestImmutableMap) == 0

let mut filterTestImmutableMap = makeFilterTestImmutableMap()

filterTestImmutableMap = ImmMap.filter((key, value) =>
  true, filterTestImmutableMap)

assert ImmMap.size(filterTestImmutableMap) == 3

// ImmMap.reject()

let mut rejectTestImmutableMap = makeFilterTestImmutableMap()

rejectTestImmutableMap = ImmMap.reject((key, value) =>
  key == Sheep, rejectTestImmutableMap)

assert ImmMap.contains(Grain, rejectTestImmutableMap)
assert !ImmMap.contains(Sheep, rejectTestImmutableMap)
assert ImmMap.contains(Brick, rejectTestImmutableMap)

let mut rejectTestImmutableMap = makeFilterTestImmutableMap()

rejectTestImmutableMap = ImmMap.reject((key, value) =>
  value == "b" || value == "s", rejectTestImmutableMap)

assert ImmMap.contains(Grain, rejectTestImmutableMap)
assert !ImmMap.contains(Sheep, rejectTestImmutableMap)
assert !ImmMap.contains(Brick, rejectTestImmutableMap)

let mut rejectTestImmutableMap = makeFilterTestImmutableMap()

rejectTestImmutableMap = ImmMap.reject((key, value) =>
  true, rejectTestImmutableMap)

assert ImmMap.size(rejectTestImmutableMap) == 0

let mut rejectTestImmutableMap = makeFilterTestImmutableMap()

rejectTestImmutableMap = ImmMap.reject((key, value) =>
  false, rejectTestImmutableMap)

assert ImmMap.size(rejectTestImmutableMap) == 3

// ImmMap.update()

let mut toUpdate = ImmMap.fromList([("a", 1), ("b", 2), ("c", 3)])

toUpdate = ImmMap.update(
  "b",
  old => {
    assert old == Some(2)
    Some(4)
  },
  toUpdate
)

assert ImmMap.get("b", toUpdate) == Some(4)

toUpdate = ImmMap.update(
  "d",
  old => {
    assert old == None
    Some(10)
  },
  toUpdate
)

assert ImmMap.get("d", toUpdate) == Some(10)

toUpdate = ImmMap.update(
  "c",
  old => {
    assert old == Some(3)
    None
  },
  toUpdate
)

assert ImmMap.contains("c", toUpdate) == false
