/* grainc-flags --no-pervasives */
module Concat

include "runtime/unsafe/wasmi32"
from WasmI32 use { (+) }
include "runtime/unsafe/memory"
include "runtime/dataStructures"
from DataStructures use { tagSimpleNumber, allocateArray }

let rec append = (list1, list2) => {
  match (list1) {
    [] => list2,
    [first, ...rest] => [first, ...append(rest, list2)],
  }
}

@unsafe
provide let listConcat = listsArray => {
  let ptr = WasmI32.fromGrain(listsArray)
  let length = WasmI32.load(ptr, 4n)
  let mut result = []

  for (let mut i = 0n; WasmI32.ltU(i, length); i += 1n) {
    let list = listsArray[tagSimpleNumber(i)]
    result = append(result, list)
  }
  result
}

@unsafe
let findLength = arr => {
  let ptr = WasmI32.fromGrain(arr)
  WasmI32.load(ptr, 4n)
}

@unsafe
provide let arrayConcat = (arraysArray: Array<Array<a>>) => {
  let numArrs = findLength(arraysArray)

  let mut totLength = 0n
  for (let mut i = 0n; WasmI32.ltU(i, numArrs); i += 1n) {
    let array = arraysArray[tagSimpleNumber(i)]
    totLength += findLength(array)
  }

  let result = allocateArray(totLength)
  let mut byteOffset = result
  for (let mut i = 0n; WasmI32.ltU(i, numArrs); i += 1n) {
    let array = arraysArray[tagSimpleNumber(i)]
    let length = findLength(array)
    for (
      let mut arrI = 0n;
      WasmI32.ltU(arrI, length);
      arrI += 1n
    ) {
      WasmI32.store(
        byteOffset,
        Memory.incRef(WasmI32.fromGrain(array[tagSimpleNumber(arrI)])),
        8n
      )
      byteOffset += 4n
    }
  }
  WasmI32.toGrain(result): Array<a>
}
