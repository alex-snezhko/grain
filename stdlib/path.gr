/**
 * @module Path: Utilities for working with system paths. This module treats paths purely as a data representation and does not provide functionality for interacting with the file system.
 * 
 * This module explicitly encodes whether a path is absolute or relative, and
 * whether it refers to a file or a directory, as part of the `Path` type.
 *
 * Paths in this module abide by a special POSIX-like representation/grammar
 * rather than one defined by a specific operating system. The rules are as
 * follows:
 * 
 * - Path separators are denoted by `/`; occurrences of `\` will be treated as part of a path segment
 * - Absolute paths may be rooted either at the POSIX-like root `/` or at Windows-like drive roots like `C:/`
 * - Paths referencing files must not include trailing forward slashes, but paths referencing directories may
 * - The path segment `.` indicates the relative "current" directory of a path, and `..` indicates the parent directory of a path
 * 
 * @example import Path from "path"
 * 
 * @since v0.5.5
 */
import String from "string"
import List from "list"
import Option from "option"
import Char from "char"

// this module is mostly a port of https://www.npmjs.com/package/@reason-native/fp
// with some modifications; reason-native license:

// MIT License
//
// Copyright (c) Facebook, Inc. and its affiliates.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

enum Token {
  Slash,
  Dot,
  Dotdot,
  DriveTok(Char),
  Text(String),
}

/**
 * @section Types: Type declarations included in the Path module.
 */

/**
 * Represents an absolute path's anchor point.
 */
export enum AbsoluteRoot {
  Root,
  Drive(Char),
}

// Rel Number represents number of directories up from base point
enum BasePath<a> {
  Rel(Number),
  Abs(AbsoluteRoot),
}

enum FileType<a> {
  File,
  Dir,
}

// NOTE dummy record names put here just to distinguish the two. These could be
// replaced with opaque types if they get added to the language
/**
 * Opaque type representing a relative path.
 */
record Relative {
  _rel: Void,
}

/**
 * Opaque type representing an absolute path.
 */
record Absolute {
  _abs: Void,
}

/**
 * Opaque type representing an path referencing a file.
 */
record File {
  _file: Void,
}

/**
 * Opaque type representing an path referencing a directory.
 */
record Directory {
  _directory: Void,
}

/**
 * Opaque type representing a system path, parameterized on
 * (relative|absolute, file|directory).
 */
type Path<a, b> = (BasePath<a>, FileType<b>, List<String>)

/**
 * Wraps each possibile path type to a variant; can be used to dynamically
 * determine the type of the path wrapped in cases where it is needed. It is
 * recommended to only make use of this type in cases where it is unavoidable.
 */
export enum PathWithType {
  AbsoluteFile(Path<Absolute, File>),
  AbsoluteDir(Path<Absolute, Directory>),
  RelativeFile(Path<Relative, File>),
  RelativeDir(Path<Relative, Directory>),
}

/**
 * Represents a platform-specific path encoding scheme.
 */
export enum PathEncoding {
  Windows,
  Posix,
}

/**
 * Represents possible errors for the `relativeTo` operation.
 */
export enum RelativizationError {
  DifferentRoots,
  ImpossibleRelativization,
}

/**
 * @section Values: Functions for working with Paths.
 */

let makeToken = str => {
  let len = String.length(str)
  match (str) {
    "." => Dot,
    ".." => Dotdot,
    _ when len == 2 && String.charAt(1, str) == ':' =>
      DriveTok(String.charAt(0, str)),
    _ => Text(str),
  }
}

let rec parseNextToken = (path: Path<a, b>, nextToken) => {
  let (base, ft, subs) = path
  match (nextToken) {
    Slash | Dot => path,
    DriveTok(label) => (base, ft, [Char.toString(label) ++ ":", ...subs]),
    Text(str) => (base, ft, [str, ...subs]),
    Dotdot => {
      match (path) {
        (_, _, [_, ...rest]) => (base, ft, rest),
        (Rel(upDirs), _, []) => (Rel(upDirs + 1), ft, []),
        (Abs(_), _, []) => path,
      }
    },
  }
}

// splits a path on forward slashes
let lexPath = pathStr => {
  let pathStr = String.trim(pathStr)
  let len = String.length(pathStr)
  let mut revTokens = []
  let mut segBeginI = 0
  for (let mut i = 0; i < len; i += 1) {
    if (String.charAt(i, pathStr) == '/') {
      if (segBeginI != i) {
        let tok = makeToken(String.slice(segBeginI, i, pathStr))
        revTokens = [tok, ...revTokens]
      }
      revTokens = [Slash, ...revTokens]
      segBeginI = i + 1
    }
  }
  if (segBeginI < len) {
    let lastPart = String.slice(segBeginI, len, pathStr)
    revTokens = [makeToken(lastPart), ...revTokens]
  }
  List.reverse(revTokens)
}

let illegalTrailingSlash = (fileType, tokens) => {
  fileType == File && List.head(List.reverse(tokens)) == Some(Slash)
}

let parseAbs = (pathStr, fileType) => {
  match (lexPath(pathStr)) {
    [] => None,
    tokens => {
      let [first, ...rest] = tokens
      let init = if (illegalTrailingSlash(fileType, tokens)) {
        None
      } else {
        match (first) {
          Slash => Some((Abs(Root), fileType, [])),
          DriveTok(label) => Some((Abs(Drive(label)), fileType, [])),
          _ => None,
        }
      }

      Option.map(init => List.reduce(parseNextToken, init, rest), init)
    },
  }
}

/**
 * Constructs a new absolute file `Path` from a string representing an absolute
 * path, using the special path grammar defined by this module.
 * 
 * @param pathStr: A string representing an absolute path
 * @returns A `Some` variant containing the absolute file path if it is successfully parsed or `None` otherwise
 * 
 * @example Path.absoluteFile("/usr/bin/bash")
 * @example Path.absoluteFile("C:/Users/me/file.txt")
 * @example Path.absoluteFile("C:\\Users\\me\\file.txt") == None // backslashes are not treated as path separators
 * @example Path.absoluteFile("/Users/me/dir/") == None // trailing slashes not allowed
 * @example Path.absoluteFile("./file.txt") == None // this is a relative path
 * 
 * @since v0.5.5
 */
export let absoluteFile = pathStr => {
  parseAbs(pathStr, File): Option<Path<Absolute, File>>
}

/**
 * Constructs a new absolute directory `Path` from a string representing an absolute
 * path, using the special path grammar defined by this module.
 * 
 * @param pathStr: A string representing an absolute path
 * @returns A `Some` variant containing the absolute directory path if it is successfully parsed or `None` otherwise
 * 
 * @example Path.absoluteDir("/usr/bin")
 * @example Path.absoluteDir("/Users/me/") // trailing slashes ok
 * @example Path.absoluteDir("./dir") == None // this is a relative path
 * 
 * @since v0.5.5
 */
export let absoluteDir = pathStr => {
  parseAbs(pathStr, Dir): Option<Path<Absolute, Directory>>
}

let parseRel = (pathStr, fileType) => {
  let (first, rest) = match (lexPath(pathStr)) {
    [] => (Dot, []),
    [first, ...rest] => (first, rest),
  }

  let init = if (illegalTrailingSlash(fileType, [first, ...rest])) {
    None
  } else {
    match (first) {
      Dot => Some((Rel(0), fileType, [])),
      Dotdot => Some((Rel(1), fileType, [])),
      Text(str) => Some((Rel(0), fileType, [str])),
      _ => None,
    }
  }

  Option.map(init => List.reduce(parseNextToken, init, rest), init)
}

/**
 * Constructs a new relative file `Path` from a string representing an relative
 * path, using the special path grammar defined by this module.
 * 
 * @param pathStr: A string representing an relative path
 * @returns A `Some` variant containing the relative file path if it is successfully parsed or `None` otherwise
 * 
 * @example Path.relativeFile("./dir/file.txt")
 * @example Path.relativeFile("/usr/bin/script.sh") == None // this is an absolute path
 * @example Path.relativeFile("./abc/") == None // trailing slash not allowed
 * 
 * @since v0.5.5
 */
export let relativeFile = pathStr => {
  parseRel(pathStr, File): Option<Path<Relative, File>>
}

/**
 * Constructs a new relative directory `Path` from a string representing an relative
 * path, using the special path grammar defined by this module.
 * 
 * @param pathStr: A string representing an relative path
 * @returns A `Some` variant containing the relative directory path if it is successfully parsed or `None` otherwise
 * 
 * @example Path.relativeDir("dir")
 * @example Path.relativeDir("./dir/") // trailing slashes ok
 * @example Path.relativeDir("/usr/bin") == None // this is an absolute path
 * 
 * @since v0.5.5
 */
export let relativeDir = pathStr => {
  parseRel(pathStr, Dir): Option<Path<Relative, Directory>>
}

/**
 * Wraps a path with its corresponding concrete path type, in order to allow
 * dynamically checking the path type.
 * 
 * @param path: The path to wrap
 * @returns A `PathWithType` wrapping the path with its type
 * 
 * @since v0.5.5
 */
export let wrapWithType = (path: Path<a, b>) => {
  match (path) {
    (Abs(_), File, _) as p => AbsoluteFile(p),
    (Abs(_), Dir, _) as p => AbsoluteDir(p),
    (Rel(_), File, _) as p => RelativeFile(p),
    (Rel(_), Dir, _) as p => RelativeDir(p),
  }
}

/**
 * Creates a new path from a path with a relative path segment appended to it.
 * 
 * @param path: The base path to append the segment to
 * @param toAppend: The relative path to append
 * @returns A new path with the `toAppend` path appended to the `path`
 * 
 * @since v0.5.5
 */
export let rec append =
  (
    path: Path<a, Directory>,
    toAppend: Path<Relative, b>,
  ) =>
  match (toAppend) {
    (Rel(up2), fileType, s2) =>
      match (path) {
        (Rel(up1), _, []) => (Rel(up1 + up2), fileType, s2),
        (Abs(_) as d, _, []) => (d, fileType, s2),
        (d, pft, [_, ...rest] as s1) => {
          if (up2 > 0) append((d, pft, rest), (Rel(up2 - 1), fileType, s2))
          else (d, fileType, List.append(s2, s1))
        },
      },
    (Abs(_), _, _) => fail "Impossible: relative path encoded as absolute path",
  }: Path<a, b>

enum DirsUp {
  Zero,
  Positive,
}

let dirsUp = x => if (x == 0) Zero else Positive

// helper function for relativizing paths; handles the correct number of
// directories to "go up" from one path to another
let rec relativizeDepth = ((up1, s1), (up2, s2)) =>
  match ((dirsUp(up1), dirsUp(up2), s1, s2)) {
    (Zero, Zero, [hd1, ...tl1], [hd2, ...tl2]) when hd1 == hd2 =>
      relativizeDepth((0, tl1), (0, tl2)),
    (Zero, Zero, [], _) => Ok((up2, s2)),
    (Zero, Zero, _, _) => Ok((List.length(s1), s2)),
    (Positive, Positive, _, _) => relativizeDepth((up1 - 1, s1), (up2 - 1, s2)),
    (Zero, Positive, _, _) => Ok((List.length(s1) + up2, s2)),
    (Positive, Zero, _, _) => Err(ImpossibleRelativization),
  }

/**
 * Attempts to construct a new relative path which will lead to the destination
 * path from the source path. If the source and destination are both absolute
 * paths but are on different roots, `Err(Path.DifferentRoots)` will be
 * returned, and if the route to the destination cannot be concretely
 * determined from the source, `Err(Path.ImpossibleRelativization)` will be
 * returned.
 * 
 * @param source: The source path to find a path from
 * @param dest: The destination path to find the path to
 * @returns An `Ok` variant containing the relative path if successfully parsed or `Err` otherwise
 * 
 * @example // relativeTo(/usr, /usr/bin) => ./bin
 * @example // relativeTo(/home/me, /home/me) => .
 * @example // relativeTo(/usr/bin, /etc) => ../../etc
 * @example // relativeTo(.., ../../thing) => ../thing
 * @example // relativeTo(/usr/bin, C:/Users) => Err(DifferentRoots)
 * @example // relativeTo(../here, ./there) => Err(ImpossibleRelativization)
 * 
 * @since v0.5.5
 */
export let relativeTo = (source: Path<a, b>, dest: Path<a, c>) => {
  let result = match ((source, dest)) {
    ((Abs(r1), _, s1), (Abs(r2), _, s2)) =>
      if (r1 != r2) Err(DifferentRoots)
      else relativizeDepth((0, List.reverse(s1)), (0, List.reverse(s2))),
    ((Rel(up1), _, s1), (Rel(up2), _, s2)) =>
      relativizeDepth((up1, List.reverse(s1)), (up2, List.reverse(s2))),
    _ => fail "",
  }

  let (_, fileType, _) = dest
  match (result) {
    Ok((depth, segs)) => Ok((Rel(depth), fileType, List.reverse(segs))),
    Err(err) => Err(err),
  }: Result<Path<Relative, c>, RelativizationError>
}

let rec segsDescendantOf = (baseSegs, pathSegs) =>
  match ((baseSegs, pathSegs)) {
    ([], _) => true,
    (_, []) => false,
    ([f1, ...r1], [f2, ...r2]) => f1 == f2 && segsDescendantOf(r1, r2),
  }

/**
 * Determines if a path is a descendant of another path.
 * 
 * @param base: The path to consider as the possible ancestor path
 * @param path: The path to consider as the possible descendant path
 * @returns `true` if the second path is a descendant of the first path and `false` otherwise
 * 
 * @example // isDescendantOf(/usr, /usr/bin/bash) == true
 * @example // isDescendantOf(/usr, /etc) == false
 * @example // isDescendantOf(../dir1, ./dir2) == false
 * 
 * @since v0.5.5
 */
export let isDescendantOf = (base: Path<a, Directory>, path: Path<a, c>) => {
  let (b1, _, s1) = base
  let (b2, _, s2) = path
  b1 == b2 && segsDescendantOf(List.reverse(s1), List.reverse(s2))
}

/**
 * Returns the path corresponding to the parent directory of the given path.
 * 
 * @param path: The path to get the parent of
 * @returns A path corresponding to the parent directory of the given path
 * 
 * @since v0.5.5
 */
export let parent = (path: Path<a, b>) =>
  match (path) {
    (base, _, [_, ...rest]) => (base, Dir, rest),
    (Rel(upDirs), _, []) => (Rel(upDirs + 1), Dir, []),
    (Abs(_) as base, _, []) => (base, Dir, []),
  }: Path<a, Directory>

/**
 * Returns the base name (named final segment) of a path.
 * 
 * @param path: The path to get the name of
 * @returns A `Some` variant containing the name of the path, or `None` if the path does not have one
 * 
 * @example Path.name(Option.unwrap(Path.relativeFile("./dir/file.txt"))) // Some("file.txt")
 * @example Path.name(Option.unwrap(Path.relativeDir(".."))) // None
 * 
 * @since v0.5.5
 */
export let name = (path: Path<a, b>) =>
  match (path) {
    (_, _, [name, ..._]) => Some(name),
    _ => None,
  }

/**
 * Returns the name of the file path without the extension.
 * 
 * @param path: The path to get the stem of
 * @returns A `Some` variant containing the stem of the file path, or `None` if the path does not have one
 * 
 * @since v0.5.5
 */
export let stem = (path: Path<a, File>) =>
  match (path) {
    (_, _, [name, ..._]) => {
      match (String.lastIndexOf(".", name)) {
        Some(dotI) => {
          let len = String.length(name)
          if (dotI > 0 && dotI < len - 1) Some(String.slice(0, dotI, name))
          else Some(name)
        },
        None => Some(name),
      }
    },
    _ => None,
  }

/**
 * Returns the extension on the name of the file path.
 * 
 * @param path: The path to get the extension of
 * @returns A `Some` variant containing the extension of the file path, or `None` if the path does not have one
 * 
 * @since v0.5.5
 */
export let extension = (path: Path<a, File>) =>
  match (path) {
    (_, _, [name, ..._]) => {
      match (String.lastIndexOf(".", name)) {
        Some(dotI) => {
          let len = String.length(name)
          if (dotI > 0 && dotI < len - 1) Some(String.slice(dotI, len, name))
          else None
        },
        None => None,
      }
    },
    _ => None,
  }

/**
 * Returns the root of the absolute path.
 * 
 * @param path: The absolute path to get the root of
 * @returns The root of the path
 * 
 * @since v0.5.5
 */
export let root = (path: Path<Absolute, b>) =>
  match (path) {
    (Abs(root), _, _) => root,
    _ => fail "Impossible: malformed absolute path data",
  }

/**
 * Converts the given `Path` into a string, using the specified path encoding.
 * A trailing slash is added to directory paths.
 * 
 * @param path: The `Path` to convert to a string
 * @param encoding: The `PathEncoding` to use to represent the path as a string
 * @returns A string representing the given path
 * 
 * @example Path.toString(myPath, Path.Windows)
 * 
 * @since v0.5.5
 */
export let toString = (path: Path<a, b>, encoding) => {
  let (base, fileType, revSegs) = path
  let sep = match (encoding) {
    Windows => "\\",
    Posix => "/",
  }
  let segs = List.reverse(revSegs)
  let segs = match (base) {
    Abs(absFrom) => {
      let prefix = match (absFrom) {
        Root => "",
        Drive(label) => Char.toString(label) ++ ":",
      }
      [prefix, ...segs]
    },
    Rel(upDirs) => {
      let goUp = List.init(upDirs, (_) => "..")
      if (goUp != []) List.append(goUp, segs) else [".", ...segs]
    },
  }
  let segs = match (fileType) {
    File => segs,
    Dir => List.append(segs, [""]),
  }
  List.join(sep, segs)
}
